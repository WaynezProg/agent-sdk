# LangChain 教學指南

## 目錄
1. [基礎概念](#基礎概念)
2. [環境設定](#環境設定)
3. [核心組件](#核心組件)
4. [進階功能](#進階功能)
5. [最佳實踐](#最佳實踐)
6. [常見問題](#常見問題)

## 基礎概念

### 什麼是 LangChain？

LangChain 是一個強大的 LLM 應用開發框架，提供了豐富的工具和組件來構建複雜的 AI 應用。它將 LLM 與外部數據源和工具連接起來，使開發者能夠創建更智能、更實用的應用程序。

### 核心優勢

1. **模組化設計**：可組合的組件，靈活的架構
2. **豐富生態**：多種 LLM 支援，豐富的工具庫
3. **生產就緒**：企業級功能，效能優化
4. **完整文檔**：詳細教程，最佳實踐指南

## 環境設定

### 安裝依賴

```bash
pip install langchain
pip install langchain-openai
pip install langchain-community
pip install python-dotenv
```

### 環境變數

創建 `.env` 檔案：

```
OPENAI_API_KEY=your_openai_api_key_here
```

## 核心組件

### 1. LLM (Large Language Models)

LangChain 支援多種 LLM 提供商：

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(
    model="gpt-3.5-turbo",
    temperature=0.1,
    max_tokens=512
)
```

### 2. 提示詞模板 (Prompts)

#### ChatPromptTemplate
```python
from langchain_core.prompts import ChatPromptTemplate

template = ChatPromptTemplate.from_messages([
    ("system", "你是一個專業的{role}，請用繁體中文回答。"),
    ("human", "請解釋什麼是{concept}？")
])
```

#### PromptTemplate
```python
from langchain_core.prompts import PromptTemplate

template = PromptTemplate(
    input_variables=["topic", "audience"],
    template="請為{audience}寫一篇關於{topic}的介紹文章："
)
```

### 3. 鏈式處理 (Chains)

#### 基本鏈
```python
from langchain_core.output_parsers import StrOutputParser

chain = prompt | llm | StrOutputParser()
result = chain.invoke({"concept": "機器學習"})
```

#### 順序鏈
```python
from langchain.chains import SequentialChain

sequential_chain = SequentialChain(
    chains=[summary_chain, detail_chain],
    input_variables=["topic"],
    output_variables=["summary", "details"]
)
```

### 4. 記憶機制 (Memory)

#### 會話記憶
```python
from langchain.memory import ConversationBufferMemory

memory = ConversationBufferMemory()
memory.save_context(
    {"input": "你好"},
    {"output": "你好！我是你的助手。"}
)
```

#### 摘要記憶
```python
from langchain.memory import ConversationSummaryMemory

memory = ConversationSummaryMemory(llm=llm)
```

### 5. 智能代理 (Agents)

```python
from langchain.agents import create_openai_functions_agent
from langchain.tools import Tool

def search_tool(query: str) -> str:
    return f"搜尋結果：{query}"

tools = [
    Tool(
        name="搜尋工具",
        description="用於搜尋資訊",
        func=search_tool
    )
]

agent = create_openai_functions_agent(llm, tools, prompt)
```

### 6. 檢索增強生成 (RAG)

```python
from langchain.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter

# 文件分割
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200
)

# 建立向量儲存
vectorstore = Chroma.from_documents(
    documents=docs,
    embedding=embeddings
)

# 建立檢索器
retriever = vectorstore.as_retriever()

# 建立 RAG 鏈
rag_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | llm
    | StrOutputParser()
)
```

## 進階功能

### 1. 自定義工具

```python
from langchain.tools import BaseTool
from typing import Optional

class CustomTool(BaseTool):
    name = "自定義工具"
    description = "這是一個自定義工具"
    
    def _run(self, query: str) -> str:
        return f"處理結果：{query}"
```

### 2. 條件鏈

```python
from langchain_core.runnables import RunnableBranch

def route_question(inputs):
    question = inputs["question"]
    if "什麼是" in question:
        return "definition"
    elif "如何" in question:
        return "how_to"
    else:
        return "general"

conditional_chain = RunnableBranch(
    (lambda x: route_question(x) == "definition", definition_chain),
    (lambda x: route_question(x) == "how_to", how_to_chain),
    general_chain
)
```

### 3. 並行處理

```python
from langchain_core.runnables import RunnableParallel

parallel_chain = RunnableParallel(
    summary=summary_chain,
    pros=pros_chain,
    cons=cons_chain
)
```

### 4. 結構化輸出

```python
from langchain_core.output_parsers import JsonOutputParser
from pydantic import BaseModel, Field

class AnalysisResult(BaseModel):
    topic: str = Field(description="主題")
    summary: str = Field(description="摘要")
    key_points: list[str] = Field(description="關鍵點")

json_parser = JsonOutputParser(pydantic_object=AnalysisResult)
```

## 最佳實踐

### 1. 提示詞工程

- **清晰的指令**：明確告訴模型要做什麼
- **具體的範例**：提供相關的範例
- **適當的約束**：設定輸出格式和長度限制
- **持續優化**：根據結果調整提示詞

### 2. 錯誤處理

```python
def safe_llm_call(inputs):
    try:
        return chain.invoke(inputs)
    except Exception as e:
        return f"處理時發生錯誤：{str(e)}"
```

### 3. 效能優化

- **批次處理**：同時處理多個請求
- **快取機制**：避免重複計算
- **串流回應**：提供即時反饋
- **並行處理**：提高處理效率

### 4. 監控和日誌

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 在鏈中添加日誌
def log_step(inputs):
    logger.info(f"處理輸入：{inputs}")
    return inputs
```

## 常見問題

### Q1: 如何處理 API 限制？

A: 可以通過以下方式處理：
- 使用批次處理減少 API 調用次數
- 實現重試機制
- 使用快取避免重複請求
- 監控 API 使用量

### Q2: 如何提高回答品質？

A: 建議：
- 優化提示詞模板
- 使用少樣本學習
- 實現多步驟推理
- 添加驗證機制

### Q3: 如何處理長文本？

A: 可以：
- 使用文本分割器
- 實現滑動窗口
- 使用摘要技術
- 分段處理

### Q4: 如何整合多個 LLM？

A: 可以：
- 使用不同的 LLM 處理不同任務
- 實現 LLM 路由
- 使用集成學習
- 比較不同模型的結果

## 學習路徑

### 初級階段
1. 環境設定與基本概念
2. LLM 模型使用
3. 提示詞模板
4. 基本鏈式處理

### 中級階段
5. 記憶機制
6. 智能代理
7. 工具整合
8. 檢索增強生成

### 進階階段
9. 嵌入向量
10. 進階功能
11. 與其他框架整合
12. 生產環境部署

## 資源連結

- [LangChain 官方文檔](https://python.langchain.com/)
- [LangChain GitHub](https://github.com/langchain-ai/langchain)
- [LangChain 社群](https://discord.gg/langchain)
- [LangChain 範例](https://github.com/langchain-ai/langchain/tree/master/templates)

## 總結

LangChain 是一個功能強大的 LLM 應用開發框架，提供了豐富的組件和工具來構建複雜的 AI 應用。通過學習 LangChain，您可以：

1. 快速構建 LLM 應用
2. 整合外部數據源和工具
3. 實現複雜的處理流程
4. 部署生產級應用

建議按照學習路徑逐步掌握各個組件，並通過實際項目來鞏固所學知識。