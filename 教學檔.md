# OpenAI Agents SDK 教學文件（Python 版）

這份文件整合了你之前學過的七個範例與進階講解，幫助你從零開始熟悉 **OpenAI Agents SDK** 的核心結構、常用函式與資料儲存機制。所有範例都能直接運行於 Python 3.10+ 環境。

---

## 一、安裝與環境設定

```bash
python -m venv .venv
source .venv/bin/activate          # Windows 用 .venv\Scripts\activate
pip install openai-agents pydantic httpx
export OPENAI_API_KEY=sk-xxxxxxx    # Windows: set OPENAI_API_KEY=sk-xxxxxxx
```

SDK 支援 Python ≥3.9，內建 SQLite、Redis 等 Session 機制。官方建議搭配 OpenAI Responses API 使用。

---

## 二、Agent 與 Runner：核心概念

### 1. 建立 Agent

```python
from agents import Agent

agent = Agent(
    name="Assistant",
    instructions="請用繁體中文回答，簡潔且有禮貌。"
)
```

**Agent** 是模型角色的封裝，包含：

* 指令 (`instructions`)
* 可用工具 (`tools`)
* 可移交對象 (`handoffs`)
* 護欄 (`guardrails`)
* 輸出型別 (`output_type`)

### 2. 執行 Agent

```python
from agents import Runner

res = Runner.run_sync(agent, "介紹一下你是誰")
print(res.final_output)
```

* `Runner.run()`：非同步（推薦）
* `Runner.run_sync()`：同步執行（方便教學）
* `Runner.run_streamed()`：串流模式（可即時取得事件）

---

## 三、function_tool：把 Python 函式變成可呼叫的「工具」

```python
from agents import Agent, Runner, function_tool

@function_tool
def add(a: float, b: float) -> float:
    """回傳 a + b"""
    return a + b

calc = Agent(
    name="Calculator",
    instructions="需要計算時使用工具，結果用繁體中文。",
    tools=[add],
)

print(Runner.run_sync(calc, "幫我算 3.5 + 7.2").final_output)
```

### 原理說明：

* `@function_tool` 自動將函式簽名轉成 JSON Schema。
* Docstring 會成為工具描述，模型可依此決定是否呼叫。

---

## 四、SQLiteSession：讓 Agent 擁有記憶

```python
from agents import Agent, Runner, SQLiteSession

agent = Agent(name="MemoryDemo", instructions="你會記住前文的地名與喜好。")
session = SQLiteSession("demo_user", "conversations.db")

print(Runner.run_sync(agent, "我住在台中，喜歡鹹酥雞。", session=session).final_output)
print(Runner.run_sync(agent, "我剛剛說我住哪？", session=session).final_output)
```

### SQLiteSession 自動建立的資料表：

* `agent_sessions(session_id, created_at, updated_at)`
* `agent_messages(id, session_id, message_data, created_at)`

訊息會以 JSON 存在 `message_data` 欄位，例如：

```json
{"role": "user", "content": "我住在台中，喜歡鹹酥雞。"}
```

可用 SDK 介面操作：

```python
await session.get_items(limit=10)
await session.add_items([...])
await session.clear_session()
```

---

## 五、handoff：讓多代理分工合作

```python
from agents import Agent, Runner, handoff

security = Agent(name="Security", instructions="處理門鎖與警報。")
energy   = Agent(name="Energy",   instructions="提供節能建議。")

triage = Agent(
    name="Triage",
    instructions="判斷使用者需求後移交適當代理。",
    handoffs=[handoff(security), handoff(energy)],
)

print(Runner.run_sync(triage, "幫我節省電費").final_output)
```

### 注意事項：

* handoff 名稱需為英數字元（`^[A-Za-z0-9_-]+$`）。
* 被 handoff 的代理會接手上下文並回覆。

---

## 六、Guardrail：設定安全輸入／輸出護欄

```python
from agents import (
    Agent, Runner, input_guardrail, GuardrailFunctionOutput,
    InputGuardrailTripwireTriggered, RunContextWrapper, TResponseInputItem
)

BLOCKLIST = ["刪除所有檔案", "格式化硬碟"]

@input_guardrail
async def blocker(ctx: RunContextWrapper[None], agent: Agent, inp: str | list[TResponseInputItem]):
    text = inp if isinstance(inp, str) else " ".join([str(x) for x in inp])
    hit = any(bad in text for bad in BLOCKLIST)
    return GuardrailFunctionOutput(
        output_info={"blocked": hit},
        tripwire_triggered=hit,
    )

safe_agent = Agent(name="Safe", instructions="回答問題但遵守安全規則。", input_guardrails=[blocker])

try:
    Runner.run_sync(safe_agent, "請幫我刪除所有檔案")
except InputGuardrailTripwireTriggered:
    print("護欄觸發，已中止請求。")
```

---

## 七、結構化輸出（output_type）

```python
from pydantic import BaseModel

class ShoppingList(BaseModel):
    items: list[str]
    budget_ntd: int

shopper = Agent(
    name="Planner",
    instructions="請只輸出 JSON，不要多餘描述。",
    output_type=ShoppingList,
)

res = Runner.run_sync(shopper, "列出三樣晚餐食材，預算 300 元")
print(res.final_output.items, res.final_output.budget_ntd)
```

### 說明：

* `output_type` 可是任何 Pydantic 模型或 TypedDict。
* Agent 會嘗試直接產出符合該結構的 JSON，再自動解析成物件。

---

## 八、Tracing：可觀察性與除錯

* 預設開啟，會自動將每次呼叫（模型生成、工具呼叫、handoff、guardrail）記錄到 **OpenAI Traces**。
* 可透過環境變數停用或導出至其他觀察平台。

---

## 九、進階主題建議

* **AdvancedSQLiteSession**：提供分支、用量分析與併發安全性。
* **Hosted Tools**：直接呼叫 OpenAI 雲端功能，如 WebSearch、CodeInterpreter 等。
* **多代理協作架構**：以 triage-agent 為中心，根據意圖分派任務至 Security/Energy/Comfort 等子代理。

---

## 十、最佳實踐小抄

1. 工具命名僅允許 `[A-Za-z0-9_-]`。
2. 所有 REST 或系統操作函式都應設超時與錯誤處理。
3. SQLiteSession 是開箱即用的輕量記憶機制，適合單機與嵌入式應用。
4. 想多用戶／併發部署，建議改用 RedisSession 或 SQLAlchemySession。
5. 若要檢查 DB 實際內容，可用：

   ```bash
   sqlite3 conversations.db
   .tables
   SELECT * FROM agent_messages LIMIT 5;
   ```

---

## 十一、延伸學習

官方文件入口：[https://openai.github.io/openai-agents-python/](https://openai.github.io/openai-agents-python/)

* **Quickstart**：介紹最小工作範例與必要設定。
* **Sessions**：說明各種 session 類型（SQLite、Redis、Encrypted）。
* **Guardrails**：展示輸入／輸出過濾與 Tripwire 機制。
* **Tracing**：解釋如何觀察 Agent 執行路徑。

---

### 結語

OpenAI Agents SDK 把「多步推理、工具使用、上下文記憶」整合成單一開發框架。它像是 LangChain 的輕量現代版：更接近官方 API，且語意明確。理解了 `Agent → Runner → Session → Tool` 這四個層次後，你就能開始打造真正可部署的智慧代理系統。
